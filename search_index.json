[["index.html", "Data-Science Reactivity: Three Ways Preface", " Data-Science Reactivity: Three Ways Ian Lyttle 2022-03-01 Preface The purpose of this book is to compare and contrast reactive data-science apps using three languages/frameworks: R: Shiny Python: Dash JavaScript: Observable An example app is created for each framework: starting with the penguins data-frame from palmerpenguins: show it as a table. specify grouping columns, aggregation columns, and an aggregation function. create an aggregated data-frame from the input, using the specification. show the aggregated data-frame as a table. The intended audience are folks who know how to develop a basic Shiny app, and wish to extend their knowledge to Dash (Python) or Observable (JavaScript). I will assume you have: basic knowledge of how to build a Shiny app. some familiarity with the Tidyverse, in particular, dplyr. In this book: we’ll review a Shiny app, highlighting parts of its code. we’ll look at a Dash app and the code. we’ll look at an Observable Notebook, where the app is the code. The goal is to give you the confidence to take the next steps to learn more about each of these frameworks. Here are some resources I have found useful: Shiny’s tutorials. Once you have built a few Shiny apps, it can be helpful to get a better sense of what makes Shiny “tick”. Joe Cheng gave an outstanding tutorial at the precursor to rstudio::conf() in 2016: Part 1, Part 2. Hadley Wickham’s Mastering Shiny. Appsilon has a handy blog post: Dash vs. Shiny. Dash’s documentation. For an introduction to Observable, this tutorial page is a great start. If you are comfortable with JavaScript and want to get a quick sense of Observable: the somewhat distractingly-named Observable’s not JavaScript. "],["shiny.html", "1 Shiny", " 1 Shiny Shiny was my introduction to reactive programming. Like many folks, I started by hacking to “get stuff working”; this is a perfectly-honorable path. Then, I watched Joe Cheng’s tutorials (Part 1, Part 2), in which he explained some of the theory behind Shiny. These talks started me on a path that completely changed my persepective and, eventually, my abilities as a programmer. This chapter is meant to be a review of Shiny; we will: touch on some of the principles I learned from Joe’s talks. show how these principles are implemented the demonstration app. "],["principles.html", "1.1 Principles", " 1.1 Principles These are some things to keep in mind to help you write more-understandable and predictable Shiny apps. 1.1.1 Pure functions vs. side effects This is the single biggest concept I have learned as a programmer, and I learned it relatively late in my career. A pure function has two properties: given the same set of arguments, it always returns the same value. it makes no changes outside of its scope. This can provide us some big benefits: it doesn’t matter where or how the return value is computed, we can rely on getting the same answer. we don’t have to worry about the environment changing as a result of calling the function. Here’s a couple of examples of pure functions: function(x) { x**2 - 1 } function(x) { paste(x, &quot; using a pure function.&quot;) } Pure functions are relatively striaghtforward to test because the output depends only on the inputs. Side effects is a catch-all term for when a function’s behavior either: depends on something not passed in as an argument. changes the something outside of its scope, e.g.: writes a file, displays a plot. Here’s a couple of functions that either depend on or cause side effects: # return value depends on the *contents* of the file, not just file_name function(file_name) { read.csv(file_name) } # this might make a change in a remote service function(url) { curl::curl(url) } Aside from being non-deterministic, functions with side effects can take a long time to execute. Of course, side effects are not necessarily bad things, but we need to be aware of them. Your Shiny server-function will make much more sense, and be much easier to debug, if you recognize pure functions and side effects. 1.1.2 Reactives vs. observers Shiny server-functions provide two broad mechanisms for updating the state of your app: reactive(): these return values, and work well with pure functions. In other words, the returned value depends only on the reactive values it depends on. observe(): there is no return value; instead, these cause side-effects. Very often, the effect is to change something in the UI, such as the choices in an input, or to render a plot. In Shiny, reactive expressions are designed to run quickly and often; observers are designed to be run sparingly. 1.1.3 Using tidyverse functions The tidyverse is designed with interactive programming in mind. It is meant to support code like this, without a lot of quotes or namespace qualifiers: penguins |&gt; group_by(island, sex) |&gt; summarise(bill_length_mm = mean(bill_length_mm)) In Shiny, variable (column) names in data frames are expressed as strings, rather than as bare variable-names. As well, in Shiny, we may want to summarise() an arbitrary set of variables. Thus, it can be a challenge to use tidyverse code in Shiny. It should not surprise us that the tidyverse offers tools to address this situation: &lt;tidy-select&gt; is a set of tools to select variables within a data frame. Functions that use &lt;tidy-select&gt; include dplyr::select(), tidyr::pivot_longer(). Of particular use in Shiny are the selection helpers for strings: dplyr::any_of() and dplyr::all_of(). across() lets us use a &lt;tidy-select&gt; specification in a data-masking function. More concretely, it lets us group_by() or summarize() over an arbitrary set of variables in a data frame. If you need to use data-masking with (by definition) a single variable, you can use subsetting with the .data pronoun, e.g. ggplot2::aes(x = .data[[str_var_x]]). "],["demonstration-app.html", "1.2 Demonstration App", " 1.2 Demonstration App The goal of this chapter is to highlight some design choices in the source code of this demonstration Shiny app. 1.2.1 Description To start with, spend a few minutes playing with the app, while referring back to these diagrams: Figure 1.1: Reactivity diagram Each input and output you see in the diagram is a part of the UI of the app. The reactive expressions, in this case: inp and agg, are found only in the app’s server-function. Figure 1.2: Legend The solid lines indicate immediate downstream-evaluation if the upstream value changes; this is what we think of when we hear “reactivity”. The dashed lines indicate that downstream-evaluation does not immediate follow an upstream change. For example, the reactive-expression agg is updated only when the button is pushed. Spend some time to study the app, to make sure that these diagrams agree with your understanding of how the app operates. In the following sections, we’ll discuss how to implement in your Shiny code. 1.2.2 Helper functions Before writing a Shiny app, I like to write out a set of non-reactive functions that will do the “heavy lifting”. To the extent possible, these are pure functions; this will make it easier to test. I keep these functions in an R folder alongside my app; here’s a link to the actual code. Just like in the app, we’ll use the palmerpenguins dataset: library(&quot;palmerpenguins&quot;) library(&quot;tibble&quot;) penguins ## # A tibble: 344 × 8 ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Adelie Torgersen 39.1 18.7 181 3750 ## 2 Adelie Torgersen 39.5 17.4 186 3800 ## 3 Adelie Torgersen 40.3 18 195 3250 ## 4 Adelie Torgersen NA NA NA NA ## 5 Adelie Torgersen 36.7 19.3 193 3450 ## 6 Adelie Torgersen 39.3 20.6 190 3650 ## 7 Adelie Torgersen 38.9 17.8 181 3625 ## 8 Adelie Torgersen 39.2 19.6 195 4675 ## 9 Adelie Torgersen 34.1 18.1 193 3475 ## 10 Adelie Torgersen 42 20.2 190 4250 ## # … with 334 more rows, and 2 more variables: sex &lt;fct&gt;, year &lt;int&gt; In fact, the first bit of code is not even a function. It is an enumeration of the choices for the aggregation function: # choices for aggregation functions agg_function_choices &lt;- c(&quot;mean&quot;, &quot;min&quot;, &quot;max&quot;) We’ll use it in a few places, so I want to define it only once. Next, a couple of functions that, given a data frame, return the names of: numerical variables categorical variables You might quibble with how I’ve defined these here, but it works for me, for this example. # given a data frame, return the names of numeric columns cols_number &lt;- function(df) { df_select &lt;- dplyr::select(df, where(~is.numeric(.x) | is.integer(.x)) ) names(df_select) } # given a data frame, return the names of string and factor columns cols_category &lt;- function(df) { df_select &lt;- dplyr::select(df, where(~is.character(.x) | is.factor(.x)) ) names(df_select) } You may have noticed that I refer to functions using the package name, e.g. dplyr::select(). This is a habit I learned following Hadley Wickham; basically: I like to be as explicit as possible when writing functions. It provides fewer opportunities for strange things to happen; I provide enough opportunities as it is. The function is more ready to be included in a package. As advertised, testing (or at least spot-verification) is straightforward: cols_number(penguins) ## [1] &quot;bill_length_mm&quot; &quot;bill_depth_mm&quot; &quot;flipper_length_mm&quot; ## [4] &quot;body_mass_g&quot; &quot;year&quot; cols_category(penguins) ## [1] &quot;species&quot; &quot;island&quot; &quot;sex&quot; Let’s look at the aggregation function: group_aggregate &lt;- function(df, str_group, str_agg, str_fn_agg, str_fn_choices = agg_function_choices) { # validate the aggregation function stopifnot( str_fn_agg %in% str_fn_choices ) # get the aggregation function func &lt;- get(str_fn_agg) df |&gt; dplyr::group_by(dplyr::across(dplyr::all_of(str_group))) |&gt; dplyr::summarise( dplyr::across(dplyr::all_of(str_agg), func, na.rm = TRUE) ) } There’s a few things I want to point out about this function: Aside from the data frame, all the arguments are strings. It is designed for use with Shiny, not for interactive use. We are using agg_function_choices to make sure that we won’t execute arbitrary code. We turn the string into binding to a function using get(). We use dplyr’s across() function, which lets us use select() semantics in “data-masking” functions, e.g. group_by(), summarise(). To select data-frame variables using strings, we use all_of(). For example if we were grouping by \"island\", then aggregating over \"bill_length_mm\" and \"bill_depth_mm\" using \"mean\", our interactive code might look like: library(&quot;dplyr&quot;, quietly = TRUE) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union aggregate_interactive &lt;- penguins |&gt; group_by(island) |&gt; summarise( bill_length_mm = mean(bill_length_mm, na.rm = TRUE), bill_depth_mm = mean(bill_depth_mm, na.rm = TRUE) ) aggregate_interactive ## # A tibble: 3 × 3 ## island bill_length_mm bill_depth_mm ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Biscoe 45.3 15.9 ## 2 Dream 44.2 18.3 ## 3 Torgersen 39.0 18.4 We can use this result to help verify that our “string” version is working: aggregate_string &lt;- group_aggregate( penguins, str_group = &quot;island&quot;, str_agg = c(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;), str_fn_agg = &quot;mean&quot; ) identical(aggregate_interactive, aggregate_string) ## [1] TRUE 1.2.3 UI The UI object is relatively straightforward; we use a fluidPage() with a narrower column for inputs and a wider column for outputs. To give a clearer view of the high-level structure of the page, I replaced the code for the inputs and outputs with ...: library(&quot;shiny&quot;) ui &lt;- fluidPage( titlePanel(&quot;Aggregator&quot;), fluidRow( column( width = 4, wellPanel( h3(&quot;Aggregation&quot;), ... )s ), column( width = 8, h3(&quot;Input data&quot;), ... hr(), h3(&quot;Aggregated data&quot;), ... ) ) ) 1.2.3.1 Inputs wellPanel( h3(&quot;Aggregation&quot;), selectizeInput( inputId = &quot;cols_group&quot;, label = &quot;Grouping columns&quot;, choices = c(), multiple = TRUE ), selectizeInput( inputId = &quot;cols_agg&quot;, label = &quot;Aggregation columns&quot;, choices = c(), multiple = TRUE ), selectizeInput( inputId = &quot;func_agg&quot;, label = &quot;Aggregation function&quot;, choices = agg_function_choices, multiple = FALSE ), actionButton( inputId = &quot;button&quot;, label = &quot;Submit&quot; ) ) One of the inputs I would like to point out is for input$cols_group. selectizeInput( inputId = &quot;cols_group&quot;, label = &quot;Grouping columns&quot;, choices = c(), multiple = TRUE ) Note that the initial choices is supplied as an empty vector. Note also that the reactivity diagram for cols_group indicates that, we use an observer function to update this input. We’ll do this in the server function, where we update the choices. 1.2.3.2 Outputs The outputs are fairly strightforward; we are using DT::DTOutput() as placeholders for DT DataTables. column( width = 8, h3(&quot;Input data&quot;), DT::DTOutput( outputId = &quot;table_inp&quot; ), hr(), h3(&quot;Aggregated data&quot;), DT::DTOutput( outputId = &quot;table_agg&quot; ) ) 1.2.4 Server function This may be a habit particular to me, but I like to organize a server-function into groups: server &lt;- function(input, output, session) # input observers # reactive expressions and values # outputs } 1.2.4.1 Input observers There are two inputs: cols_group and cols_agg, whose choices change when the input data-frame changes. To make such a change, we use a Shiny observe(), which runs when any of its reactive dependencies change. An observe() does not return a value; instead, it causes a side-effect. In this case, it changes an input element in the DOM. The observers are substantially similar, so I’ll show only cols_group: observe({ # this runs whenever the parsed input data changes updateSelectizeInput( session, inputId = &quot;cols_group&quot;, choices = cols_category(inp()) ) }) Note that one of our helper functions, cols_category(), makes an appearance. The choices for the cols_group input are updated according to the names of the categorical variables in the data frame returned by inp(). 1.2.4.2 Reactive expressions This app uses two reactive expressions: inp(), which returns the input data-frame. agg(), which returns the aggregated data-frame. inp &lt;- reactive({ palmerpenguins::penguins }) For this app, we probably did not need to wrap palmerpenguins::penguins in a reactive(). I did this with future expansion in mind, where inp() could also return a data frame according to a choice, or even a data frame parsed from an uploaded CSV file. The reactive expression for agg(), the aggregated data-frame, is more interesting: agg &lt;- reactive({ req(input$func_agg %in% agg_function_choices) group_aggregate( inp(), str_group = input$cols_group, str_agg = input$cols_agg, str_fn_agg = input$func_agg ) }) |&gt; bindEvent(input$button, ignoreNULL = TRUE, ignoreInit = TRUE) The first thing we do in the reactive is make sure that the value of input$func_agg is among the choices we specified. I’m sure you noticed that this is a redundant check. Although this is one place I strive for redundancy, I am careful to validate using the same values: agg_function_choices. You can read more about input validation in the security chapter of Mastering Shiny. Then, we use our group_aggregate() helper function. For me, having tested it outside of Shiny helped me focus on getting the rest of the code working. The reactive() expression returns the data; the expression itself is piped to bindEvent(), which will run the reactive(), and return its value, only when the value of input$button changes. This is a relatively new pattern in Shiny; it appeared in v1.6.0. bindEvent() has a couple of options: ignoreNULL = FALSE: the reactive() is not evaluated if input$button is zero. ignoreInit = FALSE: the reactive() is not evaluated when the app is first initialized. In this case, the reactive() is evaluated only in response to a button-click. This can be a useful pattern if the reactive() contains a long-running computation, or a call to an external resource. You may also be interested in Shiny’s bindCache() function. 1.2.4.3 Outputs There two outputs: one for the inp() data, the other for the agg() data; each is a table output. These outputs are similar to one another; we’ll focus on output$table_inp: output$table_inp &lt;- DT::renderDT(inp()) The table output is a straightforward use of DT::renderDT(). "],["dash.html", "2 Dash", " 2 Dash Although it is a gross oversimplification, at first glance Dash seems like Python’s answer to Shiny. Accordingly, the goals of this chapter are: to show the ways the Dash is like Shiny. to introduce the ways Dash is different from Shiny. to help you form strategies for how to “think” about Dash. To provide some context, we will use this demonstration app, and examine its code. "],["principles-1.html", "2.1 Principles", " 2.1 Principles Both Shiny and Dash use the idea of a reactive graph, which indicates what things depend on what other things: In Shiny, the reactive graph (what depends on what) is inferred using the code in reactive expressions. In Dash, it is explicit, which is a mixed blessing. For Dash, this explicitness provides the flexibility to do a lot of things, but the price is that you have to specify: all the DOM components (UI elements) in the layout. each connection between components is governed by a callback function that you provide. This is substantially similar to Shiny: part of the Dash app is used to define the UI; the rest defines what happens on the server. However, there are a couple of big considerations: the state of the app cannot be stored in the server application. it is easiest to move you data around using JSON and base64-encoded data. This is different from Shiny, which stores the state of the application in the server function. Further, Shiny manages the serialization/de-serialization of data to/from the UI; with Dash, you have to manage that yourself. These are not insurmountable obstacles, as well see in the rest of this section. For example, one way to store the state is in the UI of the app. 2.1.1 Everything that exists is a component These first two subsections are an homage to the famous John Chambers quotes: To understand computations in R, two slogans are helpful: Everything that exists is an object. Everything that happens is a function call. Similarly, everything that exists on Dash app’s web page is a component. As we’ll see in the demo, a Dash app contains a layout that you specify: app.layout = html.div(...) You need to fill in the .... A component might be a straightforward HTML element, or it might be a Dash component, where you define the attributes. The html object (imported from the dash package) behaves very similarly to R’s htmltools package; they are both based on the HTML5 spec. We’ll see more in the demo, but here’s an example of a Dash component: dcc.Dropdown(id=&#39;cols-group&#39;, multi=True) This is a dropdown component; we define the id and multi properties at definition. In this case, we don’t define the options or value properties. We’ll update the options dynamically, and let the user set the value. Like other components, dropdowns have a number of properties; we can set them either at initialization, as we did here, or we can set them using a callback. Talk about the DOM. 2.1.2 Everything that happens is a callback If you want something to happen in a Dash app, it has to happen in a callback function. Dash lets you write callbacks using Python. It also lets you write callbacks in JavaScript, but that gets beyond the scope of this book. We’ll see this in more detail in the demo app, but a callback is a standard Python function with a decorator: @app.callback(Output(&#39;cols-group&#39;, &#39;options&#39;), Input(&#39;inp&#39;, &#39;data&#39;)) def update_cols_group(data_records): return cols_choice(data_records, &#39;object&#39;) The decorator, @app.callback(...) tells Dash which layout components to map to the function’s inputs and outputs. When an Input() changes: the browser calls the Dash server to run the callback function. the Dash server runs the Python function. the Dash server sends the Output() to the browser. the browser updates the DOM. 2.1.3 Server cannot store state Managing state is a pain. However, by remaining stateless, Dash is able to easily scale to as many server instances it needs because it does not matter which instance of a callback-function responds to which browser (user) making the call. Coming from Shiny, this might seem like a show-stopper; we are used to manipulating, then storing data using the server side of an app. But there are ways around this. It’s not that you can’t store the state - you just can’t store it “here”. Your options are: store data in the DOM, then send it when needed. store data in an external database, or the like. We’ll use the first option here. Here’s one of the components in our layout: dcc.Store(id=&#39;inp&#39;, data=penguins.to_dict(&#39;records&#39;)) Note that this component is initialized using the penguins data, but that we are using pandas’ to_dict() method. This is because the component will receive the data using JSON; it is stored in the DOM as a JavaScript object. 2.1.4 Use JSON or base64 The final thing to keep in mind is that when we communicate data between the browser DOM and the callback functions, it does not use native Python objects. Instead, from the Python callback-functions’ perspective, data is serialized to JSON when sent to the DOM, and deserialized from JSON when received from the DOM. For Python dictionaries and lists containing numbers and strings, the serialization process is implied. For data frames, you have to be specific, using to_dict() or from_dict(). The other option is to use base64 encoding; I have seen this used for uploading/downloading text files, e.g. CSV or JSON files. "],["demonstration-app-1.html", "2.2 Demonstration app", " 2.2 Demonstration app 2.2.1 Description Here is the reactive graph for the demonstration app. Figure 2.1: Reactivity diagram Each rectangle is a layout component. Each circle is a callback function. Figure 2.2: Legend Information cannot flow from one component to another unless it goes through a callback function. 2.2.2 Helper functions # using only to demonstrate code; not used in Python Dash. library(&quot;reticulate&quot;) import pandas as pd from palmerpenguins import load_penguins penguins = load_penguins() print(penguins) ## species island bill_length_mm ... body_mass_g sex year ## 0 Adelie Torgersen 39.1 ... 3750.0 male 2007 ## 1 Adelie Torgersen 39.5 ... 3800.0 female 2007 ## 2 Adelie Torgersen 40.3 ... 3250.0 female 2007 ## 3 Adelie Torgersen NaN ... NaN NaN 2007 ## 4 Adelie Torgersen 36.7 ... 3450.0 female 2007 ## .. ... ... ... ... ... ... ... ## 339 Chinstrap Dream 55.8 ... 4000.0 male 2009 ## 340 Chinstrap Dream 43.5 ... 3400.0 female 2009 ## 341 Chinstrap Dream 49.6 ... 3775.0 male 2009 ## 342 Chinstrap Dream 50.8 ... 4100.0 male 2009 ## 343 Chinstrap Dream 50.2 ... 3775.0 female 2009 ## ## [344 rows x 8 columns] penguins_records = penguins.to_dict(&#39;records&#39;) def cols_choice (data_records, include): df = pd.DataFrame.from_dict(data_records) col_names = df.select_dtypes(include=include).columns.to_list() return [{&#39;label&#39;: i, &#39;value&#39;: i} for i in col_names] cols_choice(penguins_records, &#39;object&#39;) ## [{&#39;label&#39;: &#39;species&#39;, &#39;value&#39;: &#39;species&#39;}, {&#39;label&#39;: &#39;island&#39;, &#39;value&#39;: &#39;island&#39;}, {&#39;label&#39;: &#39;sex&#39;, &#39;value&#39;: &#39;sex&#39;}] cols_choice(penguins_records, &#39;number&#39;) ## [{&#39;label&#39;: &#39;bill_length_mm&#39;, &#39;value&#39;: &#39;bill_length_mm&#39;}, {&#39;label&#39;: &#39;bill_depth_mm&#39;, &#39;value&#39;: &#39;bill_depth_mm&#39;}, {&#39;label&#39;: &#39;flipper_length_mm&#39;, &#39;value&#39;: &#39;flipper_length_mm&#39;}, {&#39;label&#39;: &#39;body_mass_g&#39;, &#39;value&#39;: &#39;body_mass_g&#39;}, {&#39;label&#39;: &#39;year&#39;, &#39;value&#39;: &#39;year&#39;}] def cols_header (data_records): cols = [] if (len(data_records) &gt; 0): cols = [{&#39;name&#39;: i, &#39;id&#39;: i} for i in data_records[0].keys()] return cols cols_header(penguins_records) ## [{&#39;name&#39;: &#39;species&#39;, &#39;id&#39;: &#39;species&#39;}, {&#39;name&#39;: &#39;island&#39;, &#39;id&#39;: &#39;island&#39;}, {&#39;name&#39;: &#39;bill_length_mm&#39;, &#39;id&#39;: &#39;bill_length_mm&#39;}, {&#39;name&#39;: &#39;bill_depth_mm&#39;, &#39;id&#39;: &#39;bill_depth_mm&#39;}, {&#39;name&#39;: &#39;flipper_length_mm&#39;, &#39;id&#39;: &#39;flipper_length_mm&#39;}, {&#39;name&#39;: &#39;body_mass_g&#39;, &#39;id&#39;: &#39;body_mass_g&#39;}, {&#39;name&#39;: &#39;sex&#39;, &#39;id&#39;: &#39;sex&#39;}, {&#39;name&#39;: &#39;year&#39;, &#39;id&#39;: &#39;year&#39;}] def aggregate_df (df, cols_group, cols_agg, func_agg): if (not cols_group is None): df = df.groupby(cols_group) if (cols_agg is None or len(cols_agg) == 0): return [] dict_agg = {} for col in cols_agg: dict_agg[col] = func_agg # aggregate DataFrame df = df.agg(dict_agg).reset_index() return df aggregate_df( penguins, cols_group = &quot;island&quot;, cols_agg = [&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;], func_agg = &quot;mean&quot; ) ## island bill_length_mm bill_depth_mm ## 0 Biscoe 45.257485 15.874850 ## 1 Dream 44.167742 18.344355 ## 2 Torgersen 38.950980 18.429412 2.2.3 Compmonent layout app.layout = html.Div( className=&#39;container-fluid&#39;, children=[ dcc.Store(id=&#39;inp&#39;, data=penguins.to_dict(&#39;records&#39;)), dcc.Store(id=&#39;agg&#39;, data=[]), html.H2(&#39;Aggregator&#39;), html.Div( className=&#39;row&#39;, children =[ html.Div( className=&#39;col-sm-4&#39;, children=[ dbc.Card([ dbc.CardHeader(&#39;Aggregation&#39;), dbc.CardBody([ ... ]) ]) ] ), html.Div( className=&#39;col-sm-8&#39;, children=[ html.H3(&#39;Input data&#39;), ... html.Hr(), html.H3(&#39;Aggregated data&#39;), ... ] ) ] ) ] ) 2.2.4 Callbacks "],["observable.html", "3 Observable", " 3 Observable A few words on Observable. Figure 3.1: Reactivity diagram Figure 3.2: Legend "],["stray-thoughts.html", "A Stray Thoughts", " A Stray Thoughts Putting the code together, I have had a lot of stray thoughts that I want to get into the text. I’m thinking to collect them here, then remove them as they get expressed more concretely elsewhere in this book. Shiny and Observable are more opinionated than Dash. Shiny and Observable manage the reactive graph for you; Dash makes you spell it out explicitly. Being more opinionated lets you code more concisely. Being less opinionated gives you more flexibility in what you create, at the price of more code. Shiny lets you store the state at the server; Dash and Observable do not. Dash and Observable use React under the hood. Shiny and Dash both offer a UI/server framework; in Observable, it’s all notebook. Observable supports (and encourages) the idea of importing functions from other published notebooks. "],["field-guide-to-python.html", "B Field Guide to Python", " B Field Guide to Python In this appendix, we focus on how to get up-and-running in Python, and how you can make your Python environment reprodicible. Once you have established this, RStudio have a useful guide for how to “think” in Python, knowing R. "],["python-installation.html", "B.1 Python installation", " B.1 Python installation The first order of business is to make sure that you have a recent version of Python installed. By recent, I mean one of the last two minor version; as of February 2022, these are versions 3.10 and 3.9. To check your default Python version, just type python -V (note the captial) at the terminal command line (not the R command line). This is what I see: &gt; python -V Python 3.10.2 There is a variety of strategies for managing Python on your computer, perhaps the simplest is to go to the Python downloads page, then go from there. "],["project-management.html", "B.2 Project management", " B.2 Project management B.2.1 Git If you are creating your project directory from scratch, you will likely want to initialize a git repository in your newly-created directory: &gt; git init You will also want a .gitignore file for your project. Here’s my .gitignore file for the Dash demo app; I include some RStudio stuff for if/when I open the project in RStudio. # RStudio stuff .Rproj.user *.Rproj .Rhistory .Rdata # virtual environment venv # Byte-compiled / optimized / DLL files __pycache__/ *.py[cod] *$py.class You may wish to adapt the virtual-environment entry to your situation. B.2.2 Virtual Environment Python virtual environments are used to manage dependencies so that they are local to a project. This is a different from the classic R idea of having a single library of packages used for all projects. The idea of a project-based is also used in JavaScript (e.g. npm, yarn) and is gaining popularity in R with the renv package. In fact, this book is build using renv. The goal here is to show you how to establish and manage a virtual environment for a Dash project. In your newly-created project directory, from the terminal command-line: &gt; python -m venv ./venv This creates your Python virtual environment by creating a directory in the root of your project called venv. The name of the directory is determined by the last argument, in this case ./venv. There are a number of “standard” ways to name virtual environments; venv is one of them. It’s really up to you and your collaborators. The important thing is to make sure that you have a .gitignore entry for the virtual-environment directory. Next, let’s activate the environment. This tells your terminal that this is what you want to run when you invoke python. In your project directory, from the terminal command-line: &gt; source ./venv/bin/activate At this point, you might want to install packages into your virtual enviromment. Which packages will depend on the particulars of your project, but you can start with Dash: &gt; pip install dash Every so often, you will want to catpure which packages have been installed into your virtual environment: &gt; pip freeze &gt; requirements.txt You will want to commit requirements.txt to your git repository, as this contains the instructions for someone to reproduce your virtual environment. To reproduce it, a colleague (perhaps you!) will have to create and activate a virtual environment, then: &gt; pip install -r requirements.txt These are the very basics for how to set up and maintain a Python project. As you gain experience, you will likely adpat these ideas to your evolving needs. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
