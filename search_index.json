[["index.html", "Data-Science Reactivity: Three Ways Preface", " Data-Science Reactivity: Three Ways Ian Lyttle 2022-02-13 Preface The purpose of this book is to introduce reactive data-science apps using three languages/frameworks: R: Shiny Python: Dash JavaScript: Observable An example app is created for each framework, where you can: upload a data-frame as CSV, using palmerpenguins as default. show as a table. download as CSV. specify grouping columns, aggregation columns, and an aggregation function. create an aggregated data-frame from the input, using the specification. show as a table. download as CSV. This book may be useful for someone who knows how to develop a Shiny app, and wishes to extend their knowledge to Dash (Python) or Observable (JavaScript). I will assume you have: basic knowledge of how to build a Shiny app. some familiarity with the Tidyverse, in particular, dplyr. In this book: we’ll review a Shiny app, highlighting parts of its code. we’ll look at a Dash app and the code. we’ll look at an Observable Notebook, where the app is the code. Additional material: Shiny’s tutorial entry point. Once you have built a few Shiny apps, it can be helpful to get a better sense of what makes Shiny “tick”. Joe Cheng gave an outstanding tutorial at the precursor to rstudio::conf() in 2016: Part 1, Part 2. Hadley Wickham’s Mastering Shiny. Appsilon has a handy blog post: Dash vs. Shiny. Dash’s documentation entry point. For an introduction to Observable, this tutorial page has a lot of entry points. If you are comfortable with JavaScript and want to get a quick sense of Observable: the somewhat distractingly-named Observable’s not JavaScript. "],["shiny.html", "1 Shiny", " 1 Shiny Shiny was my introduction to reactive programming. Like many folks, I started by hacking at the keyboard to “get stuff working”; this is a perfectly-honorable path. Then, I watched Joe Cheng’s tutorials (Part 1, Part 2), in which he explained some of the theory behind Shiny. These talks started me on a path that completely changed my persepective and, eventually, my abilities as a programmer. In this chapter, I will: touch on some of the principles I learned from Joe’s talks. show these principles in the demonstration app. "],["principles.html", "1.1 Principles", " 1.1 Principles Pure functions vs. side effects. Keep side effects out of your reactive elements. Use inputs and outputs for side effects - it changes the DOM. By keeping side effects out of your reactives, you can write regular R functions to all the work in your reactives. Such R functions can live outside the “reactive universe”, which makes it easier to test your function. This came about since Joe’s talks, but it’s a powerful idea: Tidyverse: interactive programming vs. “string-based” programming. "],["demonstration-app.html", "1.2 Demonstration App", " 1.2 Demonstration App The goal of this chapter is to highlight some design choices in the source code of this demonstration Shiny app. 1.2.1 Description To start with, spend a few minutes playing with the app, while referring back to these diagrams: Figure 1.1: Reactivity diagram Each input and output you see in the diagram is a part of the UI of the app. The reactive expressions, in this case: inp and agg, are found only in the app’s server-function. The solid lines indicate immediate downstream-evaluation if the upstream value changes; this is what we think of when we hear “reactivity”. The dashed lines indicate that downstream-evaluation does not immediate follow an upstream change. For example, the reactive-expression agg is updated only when the button is pushed. Figure 1.2: Legend Spend some time to study the app, to make sure that these diagrams agree with your understanding of how the app operates. 1.2.2 Helper functions Before writing a Shiny app, I like to write out a set of non-reactive functions that will do the “heavy lifting”. To the extent possible, these are pure functions. To test things, we’ll use the palmerpenguins dataset: library(&quot;palmerpenguins&quot;) library(&quot;tibble&quot;) penguins ## # A tibble: 344 × 8 ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Adelie Torgersen 39.1 18.7 181 3750 ## 2 Adelie Torgersen 39.5 17.4 186 3800 ## 3 Adelie Torgersen 40.3 18 195 3250 ## 4 Adelie Torgersen NA NA NA NA ## 5 Adelie Torgersen 36.7 19.3 193 3450 ## 6 Adelie Torgersen 39.3 20.6 190 3650 ## 7 Adelie Torgersen 38.9 17.8 181 3625 ## 8 Adelie Torgersen 39.2 19.6 195 4675 ## 9 Adelie Torgersen 34.1 18.1 193 3475 ## 10 Adelie Torgersen 42 20.2 190 4250 ## # … with 334 more rows, and 2 more variables: sex &lt;fct&gt;, year &lt;int&gt; In fact, the first function is not even a function. It is an enumeration of the choices for the aggregation function: # choices for aggregation functions agg_function_choices &lt;- c(&quot;mean&quot;, &quot;min&quot;, &quot;max&quot;) Next, a couple of functions that, given a data frame, returns the names of: numerical variables categorical variables You might quibble with how I’ve defined these here, but it works for me, for this example. # given a data frame, return the names of numeric columns cols_number &lt;- function(df) { df_select &lt;- dplyr::select(df, where(~is.numeric(.x) | is.integer(.x)) ) names(df_select) } # given a data frame, return the names of string and factor columns cols_category &lt;- function(df) { df_select &lt;- dplyr::select(df, where(~is.character(.x) | is.factor(.x)) ) names(df_select) } You may have noticed that I refer to functions using the package name, e.g. dplyr::select(). This is a habit I learned following Hadley Wickham; basically: I like to be as explicit as possible when writing functions. It provides fewer opportunities for strange things to happen; I provide enough opportunities as it is. The function is more ready to be included in a package. The reason I write these functions is that I can test them without worrying about “reactive stuff”: cols_number(penguins) ## [1] &quot;bill_length_mm&quot; &quot;bill_depth_mm&quot; &quot;flipper_length_mm&quot; ## [4] &quot;body_mass_g&quot; &quot;year&quot; cols_category(penguins) ## [1] &quot;species&quot; &quot;island&quot; &quot;sex&quot; Let’s look at the aggregation function: group_aggregate &lt;- function(df, str_group, str_agg, str_fn_agg, str_fn_choices = agg_function_choices) { # safeguard the aggregation function stopifnot( str_fn_agg %in% str_fn_choices ) # get the aggregation function func &lt;- get(str_fn_agg) df |&gt; dplyr::group_by(dplyr::across(dplyr::all_of(str_group))) |&gt; dplyr::summarise( dplyr::across(dplyr::all_of(str_agg), func, na.rm = TRUE) ) } There’s a few things I want to point out about this function: Aside from the data frame, all the arguments are strings. It is designed for use with Shiny, not for interactive use. We are using agg_function_choices to make sure that we won’t execute arbitrary code. We turn the string into binding to a function using get(). We use dplyr’s across() function, which lets us use select() semantics in “data-masking” functions, e.g. group_by(), summarise(). To select data-frame variables using strings, we use all_of(). For example if we were grouping by \"island\", then aggregating over \"bill_length_mm\" and \"bill_depth_mm\" using \"mean\", our interactive code might look like: library(&quot;dplyr&quot;) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union penguins |&gt; group_by(island) %&gt;% summarise( bill_length_mm = mean(bill_length_mm, na.rm = TRUE), bill_depth_mm = mean(bill_depth_mm, na.rm = TRUE) ) ## # A tibble: 3 × 3 ## island bill_length_mm bill_depth_mm ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Biscoe 45.3 15.9 ## 2 Dream 44.2 18.3 ## 3 Torgersen 39.0 18.4 We can use this result to help verify that our “string” version is working: group_aggregate( penguins, str_group = &quot;island&quot;, str_agg = c(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;), str_fn_agg = &quot;mean&quot; ) ## # A tibble: 3 × 3 ## island bill_length_mm bill_depth_mm ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Biscoe 45.3 15.9 ## 2 Dream 44.2 18.3 ## 3 Torgersen 39.0 18.4 1.2.3 UI The UI object is relatively straightforward; we use a fluidPage() with a narrower column for (mostly) inputs and a wider column for outputs. To give a clearer view of the high-level structure of the page, I replaced the code for the inputs and outputs with ...: library(&quot;shiny&quot;) ui &lt;- fluidPage( titlePanel(&quot;Aggregator&quot;), fluidRow( column( width = 4, wellPanel( h3(&quot;Input data&quot;), ... ), wellPanel( h3(&quot;Aggregation&quot;), ... ), wellPanel( h3(&quot;Aggregated data&quot;), ... ) ), column( width = 8, h3(&quot;Input data&quot;), ... hr(), h3(&quot;Aggregated data&quot;), ... ) ) ) One of the inputs I would like to point out is for input$cols_group. selectizeInput( inputId = &quot;cols_group&quot;, label = &quot;Grouping columns&quot;, choices = c(), multiple = TRUE ) Note that the initial choices is supplied as an empty vector. Note also that the reactivity diagram for cols_group has a connection coming in from the “top”, rather than the side. This is to indicate that we will use a server function to update the choices for this input, using information from the inp data frame. 1.2.4 Server function This may be a habit particular to me, but I like to organize a server-function into groups: server &lt;- function(input, output, session) # input observers # reactive expressions and values # output observers # outputs } For the demo app, I am not using output-observers; each of the other categories is discussed in a section. 1.2.5 Server input-observers There are two inputs: cols_group and cols_agg, whose choices change according to the reactive-expression inp(). To make such a change, we use a Shiny observer(), which responds eagerly to any change to its reactive dependencies. An observer() does not return a value; instead, it causes a side-effect. In this case, it changes an input element in the DOM. The observers are substantially similar, so I’ll shoe only cols_group: observe({ # this runs whenever the parsed input data changes updateSelectizeInput( session, inputId = &quot;cols_group&quot;, choices = cols_category(inp()) ) }) Note that one of our helper functions, cols_category(), makes an appearance. Now, the choices for the cols_group input are taken from the names of the categorical variables in the inp() data frame. 1.2.6 Server reactive-expressions This app uses two reactive expressions: inp(), which returns the input data-frame. agg(), which reutuns the aggregated data-frame. inp &lt;- reactive({ # use palmer penguins as default if (is.null(input$upload_inp)) { return(palmerpenguins::penguins) } readr::read_csv(input$upload_inp$datapath, show_col_types = FALSE) }) |&gt; bindEvent(input$upload_inp, ignoreNULL = FALSE, ignoreInit = FALSE) Note that we have put some of the dependencies into a reactive() expression. We put a dependency on input$upload_inp, a fileInput(), into bindEvent(). This is a relatively new pattern in Shiny; it appeared in v1.6.0. bindEvent() will return the value return by the reactive(). However, it will evaluate the reactive() only when there is a change to input$upload_inp. ignoreNULL = FALSE: the reactive() is evaluated even if input$upload_inp is NULL. ignoreInit = FALSE: the reactive() is evaluated when the app is first initialized. In other words, the reactive() is under any condition. In this case, it allows the default value, palmerpenguins::penguins, to propagate when the app is initialized. The reactive expression for agg() is a little different: agg &lt;- reactive({ req(input$func_agg %in% agg_function_choices) group_aggregate( inp(), str_group = input$cols_group, str_agg = input$cols_agg, str_fn_agg = input$func_agg ) }) |&gt; bindEvent(input$button, ignoreNULL = TRUE, ignoreInit = TRUE) We are using our group_aggregate() helper function here. For me, having tested it outside of Shiny helped me focus on getting the rest of the reactive expression working. We use the bindEvent() pattern again; this time, the operative event comes from input$button. Here, all the “dotted-line” connections are implemented in the reactive(); the “solid-line” connection is made using bindEvent(). In this case: ignoreNULL = FALSE: the reactive() is not evaluated if input$button is zero. ignoreInit = FALSE: the reactive() is not evaluated when the app is first initialized. We have to wait for the button-click. Note that we use req() to validate the input. You may remember that this is validated also in our helper function. I realize that we are violating “Don’t Repeat Yourself”, but I think this merits a violation given the security consequences. You can read more about this in the security chapter of Mastering Shiny. 1.2.7 Server outputs There are a couple of sets of outputs: one for the inp() data, the other for the agg() data. Each set of outputs consists of: a table output to display the data frame. a download output to manage downloading the data frame to the user. These sets are similar to one another; we’ll focus on the set for inp(): output$table_inp &lt;- DT::renderDT(inp()) output$download_inp &lt;- downloadHandler( filename = \\() glue::glue(&quot;data-input-{Sys.Date()}.csv&quot;), content = \\(file) readr::write_csv(inp(), file) ) The table output is a straightforward use of DT::renderDT(). The downloadHandler() function is interesting, as both filename and content arguments accept functions. "],["dash.html", "2 Dash", " 2 Dash A few words on Dash. Figure 2.1: Reactivity diagram Figure 2.2: Legend "],["observable.html", "3 Observable", " 3 Observable A few words on Observable. Figure 3.1: Reactivity diagram Figure 3.2: Legend "],["stray-thoughts.html", "A Stray Thoughts", " A Stray Thoughts Putting the code together, I have had a lot of stray thoughts that I want to get into the text. I’m thinking to collect them here, then remove them as they get expressed more concretely elsewhere in this book. Shiny and Observable are more opinionated than Dash. Shiny and Observable manage the reactive graph for you; Dash makes you spell it out explicitly. Being more opinionated lets you code more concisely. Being less opinionated gives you more flexibility in what you create, at the price of more code. Shiny lets you store the state at the server; Dash and Observable do not. Dash and Observable use React under the hood. Shiny and Dash both offer a UI/server framework; in Observable, it’s all notebook. Observable supports (and encourages) the idea of importing functions from other published notebooks. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
