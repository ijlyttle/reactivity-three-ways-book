# Dash

Although it is a gross oversimplification, at first glance Dash seems like Python's answer to Shiny.

Accordingly, the goals of this chapter are:

 - to show the ways the Dash is like Shiny.
 - to introduce the ways Dash is different from Shiny.
 - to help you form strategies for how to "think" about Dash.
 
To provide some context, we will use this [demonstration app](https://aggregate-local.herokuapp.com), and examine [its code](https://github.com/ijlyttle/reactivity-demo-dash).

## Principles

Both Shiny and Dash use the idea of a reactive graph, which indicates what things depend on what other things:

 - In Shiny, the reactive graph (what depends on what) is inferred using the code in reactive expressions.

 - In Dash, it is explicit, which is a mixed blessing. 
   
For Dash, this explicitness provides the flexibility to do a lot of things, but the price is that *you* have to specify:

  - all the DOM components (UI elements) in the layout.
  - each connection between components is governed by a callback function that you provide.

This is substantially similar to Shiny: part of the Dash app is used to define the UI; the rest defines what happens on the server.

However, there are a couple of big considerations:

  - the state of the app **cannot** be stored in the server application.
  - it is easiest to move you data around using JSON and base64-encoded data.

This is different from Shiny, which stores the state of the application in the server function. 
Further, Shiny manages the serialization/de-serialization of data to/from the UI; with Dash, you have to manage that yourself.

These are not insurmountable obstacles, as well see in the rest of this section. 
For example, one way to store the state is in the UI of the app.

### Everything that exists is a component

These first two subsections are an homage to the famous John Chambers quotes:

> To understand computations in R, two slogans are helpful:
>
>  - Everything that exists is an object.
>  - Everything that happens is a function call.

Similarly, everything that exists on Dash app's web page is a component.

As we'll see in the demo, a Dash app contains a layout that you specify:

```{python, eval=FALSE}
app.layout = html.div(...)
```

You need to fill in the `...`.
A component might be a straightforward HTML element, or it might be a Dash component, where you define the attributes.

The `html` object (imported from the `dash` package) behaves very similarly to R's htmltools package; they are both based on the HTML5 spec.

We'll see more in the demo, but here's an example of a Dash component:

```{python eval=FALSE}
dcc.Dropdown(id='cols-group', multi=True)
```

This is a [dropdown component](https://dash.plotly.com/dash-core-components/dropdown); we define the `id` and `multi` properties at definition.
In this case, we don't define the `options` or `value` properties. We'll update the `options` dynamically, and let the user set the `value`.

Like other components, dropdowns have a number of [properties](https://dash.plotly.com/dash-core-components/dropdown#dropdown-properties); we can set them either at initialization, as we did here, or we can set them using a callback.

Talk about the DOM.

### Everything that happens is a callback

If you want something to happen in a Dash app, it has to happen in a callback function.
Dash lets you write callbacks using Python. 
It also lets you write callbacks in JavaScript, but that gets beyond the scope of this book.

We'll see this in more detail in the demo app, but a callback is a standard Python function with a decorator:

```{python eval=FALSE}
@app.callback(Output('cols-group', 'options'),
              Input('inp', 'data'))
def update_cols_group(data_records):
    return cols_choice(data_records, 'object')
```

The decorator, `@app.callback(...)` tells Dash which layout components to map to the function's inputs and outputs.
When an `Input()` changes:

 - the browser calls the Dash server to run the callback function.
 - the Dash server runs the Python function.
 - the Dash server sends the `Output()` to the browser.
 - the browser updates the DOM.

### Server cannot store state

Managing state is a pain.
However, by remaining stateless, Dash is able to easily scale to as many server instances it needs because it does not matter which instance of a callback-function responds to which browser (user) making the call.

Coming from Shiny, this might seem like a show-stopper; we are used to manipulating, then storing data using the server side of an app.
But there are ways around this. 
It's not that you can't store the state - you just can't store it "here". 
Your options are:

 - store data in the DOM, then send it when needed.
 - store data in an external database, or the like.

We'll use the first option here. 
Here's one of the components in our layout:

```{python eval=FALSE}
dcc.Store(id='inp', data=penguins.to_dict('records'))
```

Note that this component is initialized using the `penguins` data, but that we are using pandas' `to_dict()` method.
This is because the component will receive the data using JSON; it is stored in the DOM as a JavaScript object.

### Use JSON or base64

The final thing to keep in mind is that when we communicate data between the browser DOM and the callback functions, it does not use native Python objects. Instead, from the Python callback-functions' perspective, data is serialized to JSON when sent to the DOM, and deserialized from JSON when received from the DOM. 

For Python dictionaries and lists containing numbers and strings, the serialization process is implied. For data frames, you have to be specific, using `to_dict()` or `from_dict()`.

The other option is to use base64 encoding; I have seen this used for uploading/downloading text files, e.g. CSV or JSON files.

## Demonstration app

I've tried to brief in outlining the priniciples for a Dash app; I think they will make more sense in the context of the Dash demo-app.

### Description

Here is the reactive graph for the demonstration app.

It's a little busier than the Shiny app; Dash forces the developer to be explicit, Shiny makes some things implicit.

```{r echo=FALSE, fig.cap="Reactivity diagram for Dash"}
knitr::include_graphics("images/dash-aggregate-local.svg")
```

A few things to note about this diagram:

 - Each rectangle is a layout component; each circle is a callback function.
 
 - Components have properties, which are associated with arguments to callback functions.
 
 - When an argument to a callback function changes, the function is (re-)run.
 
 - The output(s) of callback functions are used to update the properties of components.
 
 - Functions are run, properties are updated, and so on, until the app "comes to rest".

There are a few more things formalized in the diagram, but we'll get to them as we discuss the demo app:

```{r echo=FALSE, fig.cap="Legend: reactivity diagram for Dash"}
knitr::include_graphics("images/dash-legend.svg")
```

### Helper functions

Just like in R, I like to write as much "vanilla" Python code as I can.
I want to demonstrate to myself, as much as I can, that the "guts" of the app behaves as I expect.
That way, when I'm building the components and the callbacks, I can narrow down the things that might be going wrong.

```{r}
# using only to demonstrate code; not used in Python Dash.
library("reticulate")
```

I'm reproducing this code in an RMarkdown document, so I'm using the reticulate package to run Python.
You will not need to do this to create a Dash app; you can work in a purely Python environment.

In fact, if you are newish to Python, you might find the "Field Guide" appendix useful to get things set up.
For Python programming, there is a great introduction at reticulate.

Our first step is to get a look at the `penguins` dataset, to verify it's the same as we use in R.

```{python}
import pandas as pd
from palmerpenguins import load_penguins

penguins = load_penguins()
print(penguins)
```

Because we will tell Dash to move data back and forth using a dictionary, we'll make a variable that stores `penguins` as records:

```{python}
penguins_records = penguins.to_dict('records')
print(penguins_records[0:2]) # just to get a flavor
```

Let's call this *records* format, as opposed to data-frame format.
You'll see that the records-format prints as JSON; this is a Python list, so the Dash server can send it back and forth between the server and the DOM.

For me, the biggest thing to keep in mind (other than figuring out how Pandas works) is if data is formatted as records or as a data frame.
 
The first function we'll verify is used to tell us, for a given a data frame and a given Pandas type, which columns are of that type.
(In the app, we'll convert to records-format in the callback function.)

```{python}
def cols_choice (df, include):
    col_names = df.select_dtypes(include=include).columns.to_list()
    
    return col_names
```

Let's test the function.
In Pandas, strings have type `'object'`:

```{python}  
cols_choice(penguins, 'object')
```

Numbers have type `'number'`:

```{python}
cols_choice(penguins, 'number')
```

So far, so good.

Next, we need a function to generate the (display) table properties. 
We need to return a list, with a dictionary for each column in the data frame.
Each dictionary needs elements `'name` and `'id'`, each of which has the name of the column.
As we'll see later, this is the format we need to specify the table headers.

Note that we are *not* using the data-frame format in this function, so we can keep everything in records format.
We use a trick by looking at only the first (well, zeroth) record.

```{python}
def cols_header (data_records):
    cols = []
    if (len(data_records) > 0):
        cols = [{'name': i, 'id': i} for i in data_records[0].keys()]

    return cols
  
cols_header(penguins_records)  
```

This seems OK.

Finally, we need an aggregation function. 
We send a data frame, then some lists of column-names, and a string naming an aggregation-function.
This is an exercise in Pandas - I think this works, but my lack of experience in Pandas suggests there may be a "better" way.
We'll write this as in terms of data frames; we'll convert to/from records-format in the callback function. 

```{python}
agg_function_choices = ['mean', 'min', 'max']

def aggregate_df (df, cols_group, cols_agg, func_agg,
                  str_fn_choices = agg_function_choices):
    
    if not func_agg in str_fn_choices:
        raise AssertionError(f"{func_agg} not a legal function-choice")
  
    if (not cols_group is None):
        df = df.groupby(cols_group)

    if (cols_agg is None or len(cols_agg) == 0):
        return []

    dict_agg = {}
    for col in cols_agg:
        dict_agg[col] = func_agg
    
    df = df.agg(dict_agg).reset_index()

    return df
  
aggregate_df(
  penguins, 
  cols_group = "island", 
  cols_agg = ["bill_length_mm", "bill_depth_mm"],
  func_agg = "mean"
)  
```

Confident that the "guts" of the app works, we move onto the components and the callbacks.

### Compmonent layout

```{python eval=FALSE}
app.layout = html.Div(
    className='container-fluid',
    children=[
        dcc.Store(id='inp', data=penguins.to_dict('records')),
        dcc.Store(id='agg', data=[]),
        html.H2('Aggregator'),
        html.Div(
            className='row',
            children =[
                html.Div(
                    className='col-sm-4',
                    children=[
                        dbc.Card([
                            dbc.CardHeader('Aggregation'),
                            dbc.CardBody([
                              ...
                            ])
                        ])
                    ]
                ),
                html.Div(
                    className='col-sm-8',
                    children=[
                        html.H3('Input data'),
                        ...
                        html.Hr(),
                        html.H3('Aggregated data'),
                        ...
                    ]
                )
            ]
        )
    ]
) 
```


### Callbacks
