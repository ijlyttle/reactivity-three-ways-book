# Dash

Although it is a gross oversimplification, at first glance Dash seems like Python's answer to Shiny.

Accordingly, the goals of this chapter are:

 - to show the ways the Dash is like Shiny.
 - to introduce the ways Dash is different from Shiny.
 - to help you form strategies for how to "think" about Dash.
 
To provide some context, we will use this [demonstration app](https://aggregate-local.herokuapp.com), and examine [its code](https://github.com/ijlyttle/reactivity-demo-dash).

## Principles

Both Shiny and Dash use the idea of a reactive graph, which indicates what things depend on what other things:

 - In Shiny, the reactive graph (what depends on what) is inferred using the code in reactive expressions.

 - In Dash, it is explicit, which is a mixed blessing. 
   
   
For Dash, this explicitness provides the flexibility to do a lot of things, but the price is that *you* have to specify:

  - all the DOM components (UI elements) in the layout.
  - each connection between components is governed by a callback function that you provide.

This is substantially similar to Shiny part of the Dash app is used to define the UI; the rest defines what happens on the server.

However, there are a couple of big considerations:

  - the state of the app **cannot** be stored in the server application.
  - it is easiest to move you data around using JSON and base64-encoded data.

This is different from Shiny, which stores the state of the application in the server function. 
Further, Shiny manages the serialization/de-serialization of data to/from the UI; with Dash, you have to manage that yourself.

These are not insurmountable obstacles, as well see in the rest of this section. 
For example, one way to store the state is in the UI of the app.

### Everything that exists is a component

### Everything that happens is a callback

### Server cannot store state

### Use JSON or base64

## Demonstration app

### Description

Here is the reactive graph for the demonstration app.

```{r echo=FALSE, fig.cap="Reactivity diagram"}
knitr::include_graphics("images/dash-aggregate-local.svg")
```

Each rectangle is a layout component. 
Each circle is a callback function.

```{r echo=FALSE, fig.cap="Legend"}
knitr::include_graphics("images/dash-legend.svg")
```

Information cannot flow from one component to another unless it goes through a callback function.

### Helper functions

```{r}
# using only to demonstrate code; not used in Python Dash.
library("reticulate")
```

```{python}
import pandas as pd
from palmerpenguins import load_penguins

penguins = load_penguins()
print(penguins)
```

```{python}
penguins_records = penguins.to_dict('records')
```

```{python}
def cols_choice (data_records, include):
    df = pd.DataFrame.from_dict(data_records)
    col_names = df.select_dtypes(include=include).columns.to_list()
    
    return [{'label': i, 'value': i} for i in col_names]
  
cols_choice(penguins_records, 'object')
cols_choice(penguins_records, 'number')
```

```{python}
def cols_header (data_records):
    cols = []
    if (len(data_records) > 0):
        cols = [{'name': i, 'id': i} for i in data_records[0].keys()]

    return cols
  
cols_header(penguins_records)  
```

```{python}
def aggregate_df (df, cols_group, cols_agg, func_agg):
    if (not cols_group is None):
        df = df.groupby(cols_group)

    if (cols_agg is None or len(cols_agg) == 0):
        return []
    
    dict_agg = {}
    for col in cols_agg:
        dict_agg[col] = func_agg
    
    # aggregate DataFrame
    df = df.agg(dict_agg).reset_index()

    return df
  
aggregate_df(
  penguins, 
  cols_group = "island", 
  cols_agg = ["bill_length_mm", "bill_depth_mm"],
  func_agg = "mean"
)  
```

### Compmonent layout

```{python eval=FALSE}
app.layout = html.Div(
    className='container-fluid',
    children=[
        dcc.Store(id='inp', data=penguins.to_dict('records')),
        dcc.Store(id='agg', data=[]),
        html.H2('Aggregator'),
        html.Div(
            className='row',
            children =[
                html.Div(
                    className='col-sm-4',
                    children=[
                        dbc.Card([
                            dbc.CardHeader('Aggregation'),
                            dbc.CardBody([
                              ...
                            ])
                        ])
                    ]
                ),
                html.Div(
                    className='col-sm-8',
                    children=[
                        html.H3('Input data'),
                        ...
                        html.Hr(),
                        html.H3('Aggregated data'),
                        ...
                    ]
                )
            ]
        )
    ]
) 
```


### Callbacks
